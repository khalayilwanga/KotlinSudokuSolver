package com.khalayiLwanga_SudokuGeneratorAndSolverInKotlin
import kotlin.random.Random

fun main(args:Array<String>){

// Solving a sudoku generated by Sudoku object
    val s = Sudoku()
    s.generateSudoku()
    s.solver()
    s.printSolved()

//Solving a sudoku with a known solution
    val solvableBoard = Sudoku(arrayOf(
        arrayOf(0,0,0,2,6,0,7,0,1),
        arrayOf(6,8,0,0,7,0,0,9,0),
        arrayOf(1,9,0,0,0,4,5,0,0),
        arrayOf(8,2,0,1,0,0,0,4,0),
        arrayOf(0,0,4,6,0,2,9,0,0),
        arrayOf(0,5,0,0,0,3,0,2,8),
        arrayOf(0,0,9,3,0,0,0,7,4),
        arrayOf(0,4,0,0,5,0,0,3,6),
        arrayOf(7,0,3,0,1,8,0,0,0)
    ))
    solvableBoard.solver()
    solvableBoard.printSolved()

}



class Sudoku(){
    /* INITIAL SETUP OF SUDOKU OBJECT*/

    // Variables
    private var board: Array<Array<Int>>
    private lateinit var currentPosition:List<Int>
    //    private lateinit var rands: MutableList<Int>
    private var randPositions: MutableList<List<Int>> = mutableListOf()
    private var steps:Int=0
    private var backtracks:Int=0


    // Static variables
    companion object{
        var zerosBoard : Array<Array<Int>> = Array(9){ arrayOf(0,0,0,0,0,0,0,0,0)}
        fun printZerosBoard(){
            println("[")
            zerosBoard.forEach { println("${it.asList()},") }
            println("]")
        }
    }

    // primary constructor for sudoku board to be generated from scratch
    init{
        this.board = zerosBoard
    }


    //secondary constructor if an array of arrays is provided as a parameter for the board.
    constructor( board:Array<Array<Int>>) : this() {
        this.board = board
        this.printSudoku("generated")

    }

    /* METHODS TO GENERATE INITIAL SUDOKU BOARD TO BE SOLVED*/

    // Method to generate Sudoku board from zerosBoard given the random positions to populate from generateRandomPositions().
    fun generateSudoku(): Boolean {
        this.generateRandomPositions()
        for (rand in this.randPositions) {
            for (i in 1..9){
                val randValue = i
                val validInsert:Boolean =  this.validateInsertion(randValue,rand)
                if(!validInsert ){
                    continue
                }
                this.board[rand[0]][rand[1]] = randValue
                break
            }
        }
        this.printSudoku("generated")
        return true
    }

    // Method to generate positions( stored in this.randPositions array) that are used in generateSudoku() method.
    private fun generateRandomPositions():Boolean{
        var generatedPositions = 0
        while( generatedPositions<=35){
            val rowPosition = Random.nextInt(0,8)
            val columnPosition = Random.nextInt(0,8)
            val newPosition = listOf(rowPosition,columnPosition)
            if (this.randPositions.contains(newPosition)){
                continue
            }
            this.randPositions.add(newPosition)
            generatedPositions++
        }
        return true
    }

    /* HELPER METHODS USED TO SOLVE AND GENERATE SUDOKU BOARD*/

    // Validates whether an insertion is correct or not. Should return a boolean.
    private fun validateInsertion(number:Int, position:List<Int>):Boolean{

        //Check column(vertically)
        val column = position[1]
        val row = position[0]
        for( r in 0..8){
            if (this.board[r][column]==number && r!=row){
                return false
            }
        }

        //Check row(horizontally)
        for( c in 0..8){
            if (this.board[row][c]==number && c!=column){
                return false
            }
        }

        //Check the 3*3 box
        val start_x = (row/3)*3
        val end_x = start_x+2
        val start_y = (column/3)*3
        val end_y = start_y+2
        for (x in start_x..end_x){
            for (y in start_y..end_y){
                if (this.board[x][y]== number && row!=x && column!= y){
                    return false
                }
            }
        }
        return true
    }

    /*METHODS USED TO SOLVE THE SUDOKU BOARD*/

    // Determines whether the generated sudoku is solvable.
    fun solver():Boolean{

        if (!this.findUnfilledCell()){
            return true
        }
        for( i in 1..9){
            this.steps++
            if(this.validateInsertion(i,this.currentPosition)){
                val (x,y) = this.currentPosition
                this.board[x][y] = i
                if(this.solver()){
                    return true
                }

                this.board[x][y] = 0
                this.backtracks++
                this.findUnfilledCell()

            }
            continue
        }
        return false
    }

    // Finds cells that have zeros in order to solve for them(in solver() method).
    private fun findUnfilledCell():Boolean{
        for (x in 0..8){
            for (y in 0..8){
                if(this.board[x][y]==0) {
                    this.currentPosition= listOf(x,y)
                    return true
                }
            }
        }

        return false
    }

    /* METHODS TO PRINT THE SUDOKU BOARD*/

    //Prints solution from solver()
    fun printSolved(){
        if (this.solver()){
            this.printSudoku("solved")
            println("Solved in ${this.steps} steps after backtracking ${this.backtracks} times.")
        }else{
            println("There is no solution even after backtracking ${this.backtracks} times.")
            this.printSudoku("final unsolved")
        }

    }

    //Prints current sudoku board onto the terminal
    private fun printSudoku(message:String){
        println("The $message sudoku is:")
        for (x in 0..8){
            for (y in 0..8){
                print("${this.board[x][y]} ")
                 val nextToVerticalLine = (y+1)%3==0 && y!=8
                 val nextToHorizontalLine = y==8 && (x+1)%3 ==0 && x!=8
                 val nextToRightEdge = y==8
                if(nextToVerticalLine) {
                    print(" | ")
                }
                if(nextToHorizontalLine) {
                    println("")
                    print("-----------------------")
                }
                if(nextToRightEdge) {
                    println("")
                }
            }
        }
        println("")
        return
    }
}
